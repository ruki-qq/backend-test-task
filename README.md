# Платформа для управления чат-ботами

Приложение для подключения каналов (мессенджеры/CRM/и т.п.) к чат-ботам, получения входящих сообщений через вебхук, хранения контекста диалогов и отправки ответов в каналы.

Фокус: демонстрация интеграции каналов, маршрутизации сообщений, хранения диалогов и базовой имитации LLM-ответа.


## Содержание
- Особенности и возможности
- Архитектура и стек
- Установка и запуск
- Конфигурация окружения
- API
  - Управление каналами
  - Webhook приёма сообщений
  - Формат исходящих сообщений в каналы
- Модели данных
- Логика обработки сообщений
- Тестирование
- Структура проекта


## Особенности и возможности
- Подключение нескольких каналов к одному чат‑боту
- Приём входящих сообщений из канала через вебхук
- Сохранение контекста диалогов по (chat_bot_id + chat_id)
- Игнорирование сообщений от сотрудников (employee)
- Защита от повторной обработки одного и того же сообщения (по message_id)
- Отправка ответов чат‑бота в канал, откуда пришло сообщение
- Мок-LLM (mock_llm_call) имитирует ответ ассистента
- Гибкая система логирования с настраиваемыми обработчиками
- Автоматическая генерация message_id для сообщений без идентификатора


## Архитектура и стек
- FastAPI — REST API
- Beanie (MongoDB ODM) + Motor — работа с MongoDB
- Pydantic/Pydantic Settings — схемы и конфигурация
- Loguru — расширенное логирование с кастомными обработчиками
- Uvicorn — сервер с настраиваемой конфигурацией логирования
- httpx — асинхронные HTTP-клиенты для отправки сообщений в каналы


## Установка и запуск
Требования: Python 3.13+, запущенный MongoDB

1) Клонирование и установка зависимостей

```bash
python -m venv .venv
source .venv/bin/activate
poetry install --sync
```

2) Настройка окружения (.env)

Создайте файл .env (значения по умолчанию приведены ниже в разделе «Конфигурация окружения»).

3) Запуск приложения

```bash
python -m src.main
```

По умолчанию приложение поднимется на 0.0.0.0:8000. 
Документация доступна по адресу http://localhost:8000/docs


## Конфигурация окружения
Конфигурация читается из .env (и/или переменных окружения) через pydantic-settings.

Поддерживаемые переменные:
- MONGO__URL — строка подключения к MongoDB (по умолчанию mongodb://localhost:27017)
- MONGO__DB_NAME — имя базы (по умолчанию chatbot_test)
- SERVER__WORKERS — количество воркеров uvicorn (по умолчанию 1)

Пример .env:
```env
MONGO__URL=mongodb://localhost:27017
MONGO__DB_NAME=chatbot
SERVER__WORKERS=1
```


## API
Базовый префикс — /api

### 1) Управление каналами — /api/channels/

- POST /api/channels/
  - Создать канал и привязать его к чат-боту
  - Request JSON:
    ```json
    {
      "name": "str",
      "chat_bot_id": "<ObjectId строкой>",
      "url": "https://example.com/webhook",
      "is_active": true  // необязательно, по умолчанию true
    }
    ```
  - Response JSON:
    ```json
    {
      "id": "<id канала>",
      "name": "...",
      "chat_bot_id": "<id бота>",
      "url": "https://...",
      "is_active": true,
      "token": "<автосгенерированный токен канала>"
    }
    ```

- GET /api/channels/
  - Получить список каналов
  - Параметры: chat_bot_id (опционально), active=true|false (опционально)

- GET /api/channels/{channel_id}
  - Получить канал по id

- PUT /api/channels/{channel_id}
  - Обновить поля: name, url, is_active

- DELETE /api/channels/{channel_id}
  - Удалить канал

- GET /api/channels/{channel_id}/dialogue
  - Получить историю диалога для канала (сериализованный список сообщений)


### 2) Webhook приёма сообщений — POST /api/webhook/new_message

- Заголовок авторизации (токен чат‑бота):
  - x-chatbot_auth_token: Bearer <секретный_токен_бота>
- Тело запроса (JSON):
  ```json
  {
    "message_id": "str | null",  // необязательно, генерируется автоматически если не указан
    "chat_id": "str",            // идентификатор канала
    "text": "str",
    "message_sender": "customer" | "employee"
  }
  ```
- Ответ: `{ "status": "Message processed successfully" }`

Поведение:
- Если message_sender == "employee" — сообщение игнорируется, LLM-ответ не генерируется
- Если сообщение уже обрабатывалось (совпадение по message_id) — повторная обработка игнорируется
- Для новых сообщений от клиентов:
  - Сообщение добавляется в контекст диалога (роль USER)
  - Генерируется ответ ассистента (mock_llm_call)
  - Ответ добавляется в контекст диалога (роль ASSISTANT)
  - Ответ отправляется в канал, откуда пришло сообщение


### 3) Формат исходящих сообщений в каналы
Для канала, откуда пришло сообщение, выполняется POST на URL: channel.settings.url

- Заголовки:
  - x-chat_auth_token: Bearer <token_канала>
  - Content-Type: application/json
- Тело:
  ```json
  {
    "message_id": "str",
    "role": "ASSISTANT",
    "text": "str"
  }
  ```

Примечание: токен канала выдаётся при создании канала и хранится в channel.settings.token


## Модели данных (MongoDB)

### ChatBot
- name: str
- secret_token: str

### Channel
- name: str
- chat_bot_id: ObjectId
- settings: ChannelSettings
  - url: HttpUrl
  - token: str
- is_active: bool = true

### Dialogue
- chat_bot_id: ObjectId
- chat_id: str
- message_list: DialogueMessage[]

### DialogueMessage
- role: "ASSISTANT" | "SYSTEM" | "USER" | "EMPLOYEE"
- text: str
- message_id: str

### MessageRole (Enum)
- ASSISTANT — сообщения от бота/ассистента
- SYSTEM — системные сообщения
- USER — сообщения от клиентов
- EMPLOYEE — сообщения от сотрудников


## Логика обработки сообщений
1) Вебхук получает входящее сообщение
2) Проверяется токен бота по заголовку x-chatbot_auth_token
3) Если message_id не указан, генерируется автоматически (UUID)
4) Сообщения от сотрудников (employee) игнорируются, LLM-ответ не генерируется
5) Проверка на дубликаты: по message_id
6) Сообщение пользователя добавляется в историю диалога
7) Вызывается mock_llm_call для генерации ответа ассистента
8) Ответ ассистента сохраняется в диалог
9) Ответ отправляется в канал, откуда пришло сообщение (по channel.settings.url)


## Система логирования
Приложение использует расширенную систему логирования на базе Loguru:

- Настраиваемые обработчики для разных уровней логирования
- Интеграция с Uvicorn для логирования HTTP-запросов
- Структурированное логирование с контекстом
- Возможность настройки форматов и выходных потоков


## Тестирование
1) Убедитесь, что MongoDB запущен
2) Запуск тестов (используется отдельная БД из настроек):

```bash
MONGO__URL=mongodb://localhost:27017 MONGO__DB_NAME=chatbot_test python -m pytest -v
```

Покрытие тестами:
- CRUD каналов
- Фильтрации каналов
- Webhook: успешная обработка, игнорирование сообщений от сотрудников, проверка токена/заголовков, защита от дублей
- Наличие основных роутов
- Обработка ошибок и валидация данных


## Структура проекта
```
src/
├─ app/
│  ├─ app.py                    # Инициализация FastAPI
│  ├─ routers/
│  │  └─ api/
│  │     ├─ channels.py         # API каналов
│  │     └─ webhook.py          # Webhook приёма сообщений
│  ├─ schemas/                  # Pydantic-схемы
│  ├─ services/
│  │  ├─ channel_service.py     # Логика каналов
│  │  └─ chat_service.py        # Логика чатов/диалогов/рассылок
│  └─ tests/                    # Тесты приложения
├─ core/
│  ├─ database/
│  │  ├─ models/                # Модели Beanie
│  │  └─ registry.py            # Инициализация Mongo
│  ├─ logs/                     # Система логирования
│  │  ├─ handlers.py            # Обработчики логов
│  │  └─ __init__.py            # Конфигурация логирования
│  └─ settings_model.py         # Настройки приложения
├─ predict/
│  └─ mock_llm_call.py          # Мок LLM вызова
└─ main.py                      # Точка входа
```


---

Примечание: Если интеграционная среда требует иного имени заголовка авторизации, его легко заменить в ChatService (как для входящих, так и для исходящих запросов).
